#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// --- Helper Functions ---

function parseArgs(args) {
    // (Keep the existing parseArgs function - no changes needed)
    const options = { _: [] };
    for (let i = 0; i < args.length; i++) {
        if (args[i].startsWith('--')) {
            const key = args[i].substring(2);
            const value = (i + 1 < args.length && !args[i + 1].startsWith('--')) ? args[i + 1] : true;
            options[key] = value;
            if (value !== true) i++; // Skip value in next iteration
        } else {
            options._.push(args[i]);
        }
    }
    return options;
}

function logSuccess(message) {
    console.log(`✅ ${message}`);
}

function logError(message) {
    console.error(`❌ Error: ${message}`);
}

function logInfo(message) {
    console.log(`ℹ️  ${message}`);
}

function ensureDirectoryExists(dirPath, allowExisting = false) {
    if (fs.existsSync(dirPath) && !allowExisting) {
        throw new Error(`Directory already exists: ${dirPath}. Use a different path or delete the existing one.`);
    }
    if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        logSuccess(`Created directory: ${dirPath}`);
    }
}

function writeTemplateFile(filePath, content) {
    fs.writeFileSync(filePath, content.trimStart().replace(/\r\n/g, '\n') + '\n'); // Standardize newlines
    logSuccess(`Generated ${path.basename(filePath)}`);
}

// --- Template Definitions ---

// --- Mock Server Templates (Existing) ---
const mockServerTemplates = {
    // (Keep the existing mockServerTemplates object - no changes needed)
    'package.json': (projectName) => `{
  "name": "${projectName}",
  "version": "1.0.0",
  "description": "A basic mock API server using Express and Faker.js",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "node --watch server.js"
  },
  "keywords": ["mock", "api", "server", "express", "faker"],
  "author": "Generated by Rules-LLM-Coding",
  "license": "MIT",
  "dependencies": {
    "@faker-js/faker": "^8.4.1",
    "cors": "^2.8.5",
    "express": "^4.19.2"
  }
}`,
  'server.js': (port) => `const express = require('express');
const cors = require('cors'); // Enable Cross-Origin Resource Sharing
const { faker } = require('@faker-js/faker');

const app = express();
// Use port from environment variable or default to the one specified during generation
const PORT = process.env.PORT || ${port};

app.use(cors()); // Allow requests from frontend development servers
app.use(express.json()); // Parse JSON request bodies

// --- Data Generation ---

const generateUser = (id) => ({
  id: id || faker.string.uuid(),
  firstName: faker.person.firstName(),
  lastName: faker.person.lastName(),
  email: faker.internet.email(),
  avatar: faker.image.avatar(),
  jobTitle: faker.person.jobTitle(),
  createdAt: faker.date.past(),
  updatedAt: faker.date.recent(),
});

// Generate a cache of users to simulate persistence across requests
const USER_CACHE_SIZE = 20;
const usersCache = new Map();
for (let i = 0; i < USER_CACHE_SIZE; i++) {
  const user = generateUser();
  usersCache.set(user.id, user);
}

console.log(\`Generated \${usersCache.size} mock users.\`);

// --- Mock API Endpoints ---

// GET /users - List users with basic pagination simulation
app.get('/users', (req, res) => {
  console.log(\`GET /users received (query: \${JSON.stringify(req.query)})\`);
  const page = parseInt(req.query.page || '1', 10);
  const limit = parseInt(req.query.limit || '10', 10);
  const sortBy = req.query.sortBy || 'createdAt';
  const order = req.query.order || 'desc'; // 'asc' or 'desc'

  const allUsers = Array.from(usersCache.values());

  // Simple sorting
  allUsers.sort((a, b) => {
      let comparison = 0;
      if (a[sortBy] < b[sortBy]) comparison = -1;
      if (a[sortBy] > b[sortBy]) comparison = 1;
      return order === 'desc' ? comparison * -1 : comparison;
  });

  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;
  const results = allUsers.slice(startIndex, endIndex);
  const totalItems = allUsers.length;
  const totalPages = Math.ceil(totalItems / limit);

  // Simulate API response delay
  setTimeout(() => {
    res.json({
      data: results,
      meta: {
        currentPage: page,
        itemsPerPage: limit,
        totalItems: totalItems,
        totalPages: totalPages,
      },
    });
  }, faker.number.int({ min: 100, max: 500 })); // Simulate 100-500ms delay
});

// GET /users/:id - Get a specific user
app.get('/users/:id', (req, res) => {
  const { id } = req.params;
  console.log(\`GET /users/\${id} received\`);
  const user = usersCache.get(id);

  // Simulate API response delay
  setTimeout(() => {
    if (user) {
      res.json(user);
    } else {
      res.status(404).json({ error: 'User not found' });
    }
  }, faker.number.int({ min: 50, max: 300 }));
});

// POST /users - Create a new user
app.post('/users', (req, res) => {
  console.log(\`POST /users received (body: \${JSON.stringify(req.body)})\`);
  const { firstName, lastName, email } = req.body;

  // Basic validation example
  if (!firstName || !lastName || !email) {
    return res.status(400).json({ error: 'Missing required fields: firstName, lastName, email' });
  }

  const newUser = generateUser(); // Generate a new user with a new ID
  newUser.firstName = firstName;
  newUser.lastName = lastName;
  newUser.email = email; // Use provided email if valid
  newUser.createdAt = new Date();
  newUser.updatedAt = new Date();

  usersCache.set(newUser.id, newUser);
  console.log(\`Created user \${newUser.id}\`);

  // Simulate API response delay
  setTimeout(() => {
    res.status(201).json(newUser);
  }, faker.number.int({ min: 200, max: 600 }));
});

// PUT /users/:id - Update an existing user
app.put('/users/:id', (req, res) => {
    const { id } = req.params;
    console.log(\`PUT /users/\${id} received (body: \${JSON.stringify(req.body)})\`);
    const existingUser = usersCache.get(id);

    if (!existingUser) {
        return setTimeout(() => res.status(404).json({ error: 'User not found' }), faker.number.int({ min: 50, max: 300 }));
    }

    // Update only provided fields (simple merge)
    const updatedFields = req.body;
    const updatedUser = { ...existingUser, ...updatedFields, updatedAt: new Date() };

    // Ensure ID is not changed
    updatedUser.id = id;

    usersCache.set(id, updatedUser);
    console.log(\`Updated user \${id}\`);

    setTimeout(() => {
        res.json(updatedUser);
    }, faker.number.int({ min: 150, max: 450 }));
});

// DELETE /users/:id - Delete a user
app.delete('/users/:id', (req, res) => {
  const { id } = req.params;
  console.log(\`DELETE /users/\${id} received\`);

  // Simulate API response delay
  setTimeout(() => {
    if (usersCache.has(id)) {
      usersCache.delete(id);
      console.log(\`Deleted user \${id}\`);
      res.status(204).send(); // No content on successful delete
    } else {
      res.status(404).json({ error: 'User not found' });
    }
  }, faker.number.int({ min: 250, max: 700 }));
});

// Catch-all for undefined routes
app.use((req, res) => {
  console.log(\`404 Not Found: \${req.method} \${req.originalUrl}\`);
  res.status(404).send({ error: 'Not Found' });
});

// --- Start Server ---
app.listen(PORT, () => {
  console.log(\`\\n🚀 Basic Mock API server listening at http://localhost:\${PORT}\`);
  console.log('Available endpoints:');
  console.log(\`  GET    http://localhost:\${PORT}/users\`);
  console.log(\`  GET    http://localhost:\${PORT}/users/:id\`);
  console.log(\`  POST   http://localhost:\${PORT}/users\`);
  console.log(\`  PUT    http://localhost:\${PORT}/users/:id\`);
  console.log(\`  DELETE http://localhost:\${PORT}/users/:id\`);
  console.log('\\nUse Ctrl+C to stop.');
});`,
  'Dockerfile': () => `# Use an official Node.js runtime as a parent image
FROM node:20-alpine AS base

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

# Port is now determined by env var or the value in server.js
# EXPOSE is more for documentation here; the actual port is set in server.js
# You might need to map the correct port during deployment
EXPOSE 3001

CMD [ "node", "server.js" ]`,
  'README.md': (projectName, dirPath, port) => `# ${projectName} - Basic Node.js Mock API Server

This directory contains a simple mock API server built with Node.js, Express, and Faker.js, generated by the \`Rules-LLM-Coding\` scaffolding script. It simulates a basic \`/users\` REST API endpoint structure.

## Purpose

- Provide a quick-start mock API for frontend development.
- Demonstrate generating fake data with Faker.js.
- Show basic routing and response simulation with Express.

## Setup

1.  **Prerequisites:** Ensure you have [Node.js](https://nodejs.org/) (v18 or later recommended) and npm installed.
2.  **Install Dependencies:** Navigate to this directory (\`${dirPath}\`) in your terminal and run:
    \`\`\`bash
    npm install
    \`\`\`

## Running the Server

You can run the server in two ways:

1.  **Standard Start:**
    \`\`\`bash
    npm start
    \`\`\`
    The server will start on \`http://localhost:${port}\` (or the port specified by the \`PORT\` environment variable).

2.  **Development Mode (with auto-restart on changes):**
    > Requires Node.js v18.11.0 or later.
    \`\`\`bash
    npm run dev
    \`\`\`
    The server will start and automatically restart if you modify \`server.js\`.

## Available Endpoints

The server mocks the following endpoints on \`http://localhost:${port}\`:

- \`GET /users\`
- \`GET /users/:id\`
- \`POST /users\`
- \`PUT /users/:id\`
- \`DELETE /users/:id\`

(Refer to \`server.js\` for details on request/response formats and simulated delays.)

## Deployment

This server includes a \`Dockerfile\` and can be deployed to various PaaS providers like Render or Fly.io.

### Option 1: Render
(See general Render documentation - ensure you set the Root Directory correctly to \`${dirPath}\` relative to your repo root and the start command is \`node server.js\`.)

### Option 2: Fly.io
(Navigate to \`${dirPath}\` and run \`fly launch\`. It should detect the Dockerfile.)

### General Considerations
- Use environment variables (e.g., \`PORT\`) for configuration on your hosting platform.
- HTTPS is usually handled automatically by the PaaS.
`,
  '.dockerignore': () => `.git
node_modules
npm-debug.log
Dockerfile
.dockerignore
README.md
`
};

// --- NEW: Prisma Seeder Templates ---
const prismaSeederTemplates = {
    'package.json': (projectName) => `{
  "name": "${projectName}",
  "version": "1.0.0",
  "description": "Database seeding example using Prisma and Faker.js",
  "main": "prisma/seed.js",
  "scripts": {
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:seed": "node prisma/seed.js"
  },
  "keywords": ["prisma", "seed", "database", "faker"],
  "author": "Generated by Rules-LLM-Coding",
  "license": "MIT",
  "devDependencies": {
    "@faker-js/faker": "^8.4.1",
    "prisma": "^5.14.0"
  },
  "dependencies": {
    "@prisma/client": "^5.14.0"
  },
  "prisma": {
    "seed": "node prisma/seed.js"
  }
}`,

    'prisma/schema.prisma': () => `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Default: PostgreSQL. Change to "mysql", "sqlite", "sqlserver", "mongodb" if needed
  url      = env("DATABASE_URL")
}

// --- Example Models ---

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  profile   Profile?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique // Relation scalar field (used in the `@relation` attribute below)
  user   User    @relation(fields: [userId], references: [id])
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
`,

    'prisma/seed.js': () => `const { PrismaClient } = require('@prisma/client');
const { faker } = require('@faker-js/faker');

const prisma = new PrismaClient();

const USER_COUNT = 10;
const POSTS_PER_USER = 3;

async function main() {
  console.log('Seeding database...');

  // Clear existing data (optional, be careful in production!)
  console.log('Deleting existing data...');
  await prisma.post.deleteMany();
  await prisma.profile.deleteMany();
  await prisma.user.deleteMany();
  console.log('Deleted existing data.');

  // Seed Users and their related data
  console.log(\`Generating ${USER_COUNT} users...\`);
  const userPromises = [];
  for (let i = 0; i < USER_COUNT; i++) {
    userPromises.push(
      prisma.user.create({
        data: {
          name: faker.person.fullName(),
          email: faker.internet.email({ firstName: \`user\${i}\` }).toLowerCase(), // Ensure unique emails
          profile: {
            create: {
              bio: faker.lorem.sentence(),
            },
          },
          posts: {
            create: Array.from({ length: POSTS_PER_USER }).map(() => ({
              title: faker.lorem.words({ min: 3, max: 7 }),
              content: faker.lorem.paragraphs(2),
              published: faker.datatype.boolean(0.7), // 70% chance of being published
            })),
          },
        },
        include: { // Include related data in the result (optional)
          profile: true,
          posts: true,
        },
      })
    );
  }

  const users = await Promise.all(userPromises);
  console.log(\`Successfully created ${users.length} users with profiles and posts.\`);

}

main()
  .catch((e) => {
    console.error('Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    console.log('Disconnecting Prisma Client...');
    await prisma.$disconnect();
    console.log('Seeding finished.');
  });
`,

  'README.md': (projectName, dirPath) => `# ${projectName} - Database Seeding Example

This directory contains a database seeding example using Node.js, Prisma, and Faker.js, generated by the \`Rules-LLM-Coding\` scaffolding script.

## Purpose

- Demonstrate how to set up Prisma for database interactions.
- Show how to generate realistic seed data using Faker.js.
- Provide a runnable script to populate a development database.

## Prerequisites

- [Node.js](https://nodejs.org/) (v18 or later recommended) and npm installed.
- A running database instance supported by Prisma (e.g., PostgreSQL, MySQL, SQLite). PostgreSQL is used by default in \`schema.prisma\`.
- A tool to interact with your database (optional, e.g., \`psql\`, DBeaver, TablePlus).

## Setup

1.  **Navigate to Directory:**
    \`\`\`bash
    cd ${dirPath}
    \`\`\`

2.  **Install Dependencies:**
    \`\`\`bash
    npm install
    \`\`\`

3.  **Configure Database Connection:**
    *   Copy the example environment file:
        \`\`\`bash
        cp .env.example .env
        \`\`\`
    *   Edit the \`.env\` file and set the \`DATABASE_URL\` variable to your database connection string. Example formats:
        *   PostgreSQL: \`postgresql://USER:PASSWORD@HOST:PORT/DATABASE\`
        *   MySQL: \`mysql://USER:PASSWORD@HOST:PORT/DATABASE\`
        *   SQLite: \`file:./dev.db\` (Prisma will create this file)

4.  **Apply Database Schema:**
    *   This command creates the database if it doesn't exist (for PostgreSQL/MySQL), applies the schema defined in \`prisma/schema.prisma\`, and generates the Prisma Client based on your schema.
    \`\`\`bash
    npx prisma migrate dev --name init
    \`\`\`
    *   *(Optional)* If you change the schema later, run \`npx prisma migrate dev --name <migration_name>\` again.

## Running the Seeder

Once setup is complete, run the seed script:

\`\`\`bash
npm run prisma:seed
\`\`\`

This command executes \`node prisma/seed.js\`, which will (by default):
1. Delete existing data in the User, Profile, and Post tables.
2. Generate and insert new mock data using Faker.js.

Check your database to confirm the data has been seeded.

## Customization

- **Schema:** Modify the models defined in \`prisma/schema.prisma\`. Remember to run \`npx prisma migrate dev\` after changes.
- **Seeding Logic:** Edit \`prisma/seed.js\` to change the number of records generated, the data fields, relationships, or generation logic.
- **Database Type:** Change the \`provider\` in the \`datasource db\` block in \`prisma/schema.prisma\` and update your \`DATABASE_URL\` accordingly.
`,

   '.env.example': () => `# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# Example for PostgreSQL (Replace with your actual connection details)
DATABASE_URL="postgresql://user:password@localhost:5432/mydatabase?schema=public"

# Example for MySQL
# DATABASE_URL="mysql://user:password@localhost:3306/mydatabase"

# Example for SQLite
# DATABASE_URL="file:./dev.db"
`,
};


// --- Main Logic ---

const args = parseArgs(process.argv.slice(2));
const command = args._[0];

function printUsage() {
    logInfo('Usage: node scripts/generate.js <template_type> --path <output_directory> [options]');
    logInfo('');
    logInfo('Available Types:');
    logInfo('  mock-server      Generates a basic Node.js/Express mock API server.');
    logInfo('  prisma-seeder    Generates a basic Node.js/Prisma database seeder.');
    logInfo('');
    logInfo('Common Options:');
    logInfo('  --path <path>    (Required) The directory where files will be generated.');
    logInfo('');
    logInfo('Options for mock-server:');
    logInfo('  --port <number>  (Optional) Port for the server (default: 3001).');
    logInfo('');
    logInfo('Options for prisma-seeder:');
    logInfo('  (No specific options currently)');

}

if (!command) {
    printUsage();
    process.exit(1);
}

try {
    const targetPath = args.path;
    if (!targetPath) {
        throw new Error('--path option is required');
    }
    const absoluteTargetPath = path.resolve(targetPath);
    const projectName = path.basename(absoluteTargetPath);

    // --- Command Handling ---
    if (command === 'mock-server') {
        const port = args.port || 3001;

        ensureDirectoryExists(absoluteTargetPath);

        writeTemplateFile(path.join(absoluteTargetPath, 'package.json'), mockServerTemplates['package.json'](projectName));
        writeTemplateFile(path.join(absoluteTargetPath, 'server.js'), mockServerTemplates['server.js'](port));
        writeTemplateFile(path.join(absoluteTargetPath, 'Dockerfile'), mockServerTemplates['Dockerfile']());
        writeTemplateFile(path.join(absoluteTargetPath, 'README.md'), mockServerTemplates['README.md'](projectName, targetPath, port));
        writeTemplateFile(path.join(absoluteTargetPath, '.dockerignore'), mockServerTemplates['.dockerignore']());

        logInfo(`\nMock server '${projectName}' generated successfully in ${targetPath}`);
        logInfo(`Next steps:`);
        logInfo(`  1. cd ${targetPath}`);
        logInfo(`  2. npm install`);
        logInfo(`  3. npm start (or npm run dev)`);

    } else if (command === 'prisma-seeder') {
        ensureDirectoryExists(absoluteTargetPath);
        const prismaDir = path.join(absoluteTargetPath, 'prisma');
        ensureDirectoryExists(prismaDir, true); // Ensure prisma subdir exists, allow if root exists

        writeTemplateFile(path.join(absoluteTargetPath, 'package.json'), prismaSeederTemplates['package.json'](projectName));
        writeTemplateFile(path.join(prismaDir, 'schema.prisma'), prismaSeederTemplates['prisma/schema.prisma']());
        writeTemplateFile(path.join(prismaDir, 'seed.js'), prismaSeederTemplates['prisma/seed.js']());
        writeTemplateFile(path.join(absoluteTargetPath, 'README.md'), prismaSeederTemplates['README.md'](projectName, targetPath));
        writeTemplateFile(path.join(absoluteTargetPath, '.env.example'), prismaSeederTemplates['.env.example']());

        logInfo(`\nPrisma seeder example '${projectName}' generated successfully in ${targetPath}`);
        logInfo(`Next steps:`);
        logInfo(`  1. cd ${targetPath}`);
        logInfo(`  2. npm install`);
        logInfo(`  3. cp .env.example .env (and configure DATABASE_URL)`);
        logInfo(`  4. npx prisma migrate dev --name init (to setup database schema)`);
        logInfo(`  5. npm run prisma:seed (to run the seeder)`);

    } else {
        throw new Error(`Unknown template type: ${command}`);
    }
    process.exit(0);
} catch (error) {
    logError(error.message);
    printUsage(); // Show usage on error
    process.exit(1);
}